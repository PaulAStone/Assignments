---
title: "Phylogenetic Diversity - Traits"
author: "Z620: Quantitative Biodiversity, Indiana University"
date: "February 20, 2015"
header-includes:
   - \usepackage{array}
output: pdf_document
geometry: margin=2.54cm
---

## OVERVIEW

## 1) SETUP
### A. Retrieve and Set Your Working Directory

```{r, results = 'hide'}
rm(list = ls())
getwd()
setwd("~/GitHub/QuantitativeBiodiversity/Assignments/PhyloTraits")
```

### B. Load Packages 

What are these packages and why are we using them?

```{r, results = 'hide', message = FALSE, warning = FALSE} 
require("muscle")
require("ape")
require("seqinr")
require("phangorn")
```

## 2) DESCRIPTION OF DATA
The maintenance of biodiversity is thought to be influenced by trade-offs among species. 
One such trade-off involves species that are highly specialized at using a single resource. 
However, this may come at the cost of not being able to use other resoruces as well.
We set out to test this hypothesized trade-off in bacteria by assessing generalist and specialist strategies on different forms of phopshorus, which commonly limits growth and reproduction of populations in freshwater ecosystems.
Here, we take a phylogenetic approach to mapping resource utilizataion traits onto a phylogenetic tree while testing for specialist-generalist trade-offs. 

## 3) SEQUENCE ALIGNMENT
Often, the first step in a phylogenetic analysis after generating or retrieving sequence data is to perform an alignment. 
There are many programs available for performing alignments. 
In R, there are at least two packages that can be used for aligning sequences: `ape` and `muscle`. 
In `ape`, alignments can be done with the functions `clustal`, `muscle`, and `tcoffee`, all which seem to have a range of options. 
However, these functions require that other programs be installed on your computer.
We are going to use the `muscle` package in R becasue it will align sequences in a "stand alone" fashion without the need for installing additional software. 

```{r}
seq.aln <- muscle::muscle(seqs="./data/p.isolates.fasta", out = "./data/p.isolates.afa") 
```

## 4) VISUALIZING ALIGNMENTS
It is good practice to view your sequences after alignment. 
This may not be practical for large databases, but in our example, we're only dealing with 45 sequences plus an outgroup sequence. 
After reading in the fasta-aligned file, we will convert it to a DNAbin object.
This is a  bit-level coding scheme that allows R to store and manipulate sequence data.
Last, we will visualize the alignment by color-coding bass different colors. 

```{r}
read.aln <- read.alignment(file = "./data/p.isolates.afa", format = "fasta") # seqinr command
p.DNAbin <- as.DNAbin(read.aln) # ape command to convert fasta file into DNAbin filetype
x <- p.DNAbin[,100:500] # identify region (in bp of 16S rRNA) to visuzlize
image(x, cex.lab = 0.5) # ape command to visusalize seq align
grid(ncol(x),nrow(x),col="lightgrey") # ape command to add grid
```

***Question 1***:  Make some observations about the `muscle` alingmnet of the 16S rRNA gene sequences for our bacterial isoaltes. Approximatley how long were our reads? 

> ***Answer 1***: 

## 5) MODELS OF DNA EVOLUTION
Phylogenetic analyses require assumptions about the rates of DNA evolution. 
Various models have been developed to estimate the rates that nucleotides change, which can be important for inferring relatedness of genes.
For example, the **Jukes-Cantor model (JC69)** is the simplest **substitution model**.
It assumes all that nucleotides occur at equal frequencies and that these nucleotides can mutate from one to another with equal probability. 
The **Felenstein model (F81)** builds from JC69 by allowing base frequences to vary. 
The **Kimura model (K80)** also assumes equal frequencies of nucleotides, but recognizes that transition mutations (e.g., purine to a purine [A -> G] or pyrmidine to pyrmidine [C -> T]) occur with higher probability than tranversion mutations (e.g., purine to pyrmidine or vice-versa).
**Hasegawa, Kishino, and Yano (HKY85)** merges elements of F81 and K80 by accounting for uneuqal base frequencies and differences in the rates of transitions and tranversions. 
Many other models of DNA evolution exist, which take into account features such as G+C bias and the probabilities associated with time-reversible nucleotide changes (e.g., T -> C -> T).
Fortunately, the `ape` package has a function (`dist.dna`) that will create distances for a large number of DNA substitution models. 

```{r}
seq.dist <- dist.dna(p.DNAbin, model = "K80", pairwise.deletion = FALSE) # ape: Kimuraâ€™s 2-parameters distance
```

## 6) PHYLOGENETIC RECONSTRUCTION
Phylogenetic trees...

### NEIGHBOR JOINING
Neighbor joining trees take a distance matrix based on comparisons of pairs of sequences.
Trees are then constructed in an agglomerative fashion similar to the methods used in cluster analysis. 
Neighbor joining is a relatively fast algorithm and often generates correct tree topologies. 
However, today, other non-distance-based phylogenetic methods are more commonly used. 

***NOT SURE WE NEED TO DO BOTH NJ AND UPGMA***
```{r}
nj.tree <- nj(seq.dist) # ape command for Neighbor Joining
outgroup <- match("Methanosarcina", nj.tree$tip.label)
nj.rooted <- root(nj.tree, outgroup, resolve.root=TRUE)
upgma.tree <- upgma(seq.dist)
upgma.rooted <- root(upgma.tree, outgroup, resolve.root=TRUE)
layout(matrix(c(1,2), 2, 1), height=c(2,2))
par(mar = c(1,1,1,1))
plot.phylo(nj.rooted, main = "NJ", "phylogram", use.edge.length = FALSE, direction = "right", cex = 0.5, label.offset = 1) # ape command
plot(upgma.rooted, main = "UPGMA", use.edge.length = FALSE, direction = "right", cex = 0.5, label.offset = 1)
```

## 7) MAXIMIM PARSIMONY
Using package `phangorn`.
Requires phyDat formatted objects.
There are functions like `optim.parsimony` that peforms tree rearragements via nearest-neighbor exchange and `pratchet` which uses parsimony ratchet to find trees with lower parsimony score.
Type the following at the R terminal for a detailed exmaple: vignette('Trees')

```{r}
# read.aln.mat <- as.matrix(read.aln)
# read.aln.phydat <- phyDat(p, type = "DNA")
# seq.dist.phydat <- dist.dna(as.DNAbin(read.aln.phydat))
# tree.nj <- nj(seq.dist.phydat)
# parsimony(tree.nj, read.aln.phydat)
# tree.pars <- optim.parsimony(tree.nj, read.aln.phydat)
# tree.ratch <- pratchet(read.aln.phydat, trace = 0)
# parsimony(c(tree.pars,tree.ratch),read.aln.phydat)
# plot(tree.pars, main = "parsimony", use.edge.length = FALSE, direction = "right", cex = 0.5, label.offset = 1)
```

## 6) MAXIMUM LIKELIHOOD ESTIMATION AND BOOTSTRAP SUPPORT
** Beware really long, something is not right. 
** Discussed by Paradis (2012) on pp 138-159
** Problems with `pml`
** We should consider `mlphylo` in `ape`
** Can't seem to find it despite this page: http://svitsrv25.epfl.ch/R-doc/library/ape/html/mlphylo.html

ml <- mlphylo(p.DNAbin, model = DNAmodel("JC69"))

```{r}
# read.aln.mat <- as.matrix(read.aln)
# read.aln.phydat <- phyDat(read.aln.mat, type = "DNA")
# ml <- pml(nj.rooted, data = read.aln.phydat, k =4, inv = 0.2) 
# 
# seq.dist.phydat
# 
# 
# ml <- pml(tree.nj, data = seq.dist.phydat) 
# 
# seq.dist.phydat
# 
# 
# data(yeast)
# tree <- NJ(dist.logDet(yeast))
# fit <- pml(tree, yeast, k=4, inv=0.2)

```

## 7) MAPPING TRAITS ONTO TREES

### A. Loading Trait Database
```{r}
p.growth <- read.table("./data/p.isolates.stdgrowth.txt", sep = "\t", header = TRUE, row.names = 1)
#p.growth <- as.data.frame(t(p.growth))
```


### Mapping Traits on Tree
```{r}
nj.tree <- bionj(seq.dist) # ape command for Neighbor Joining
outgroup <- match("Methanosarcina", nj.tree$tip.label)
nj.rooted <- root(nj.tree, outgroup, resolve.root=TRUE)
nj.rooted <- drop.tip(nj.rooted, "Methanosarcina")
traits <- p.growth[,c("ATP", "SRP", "PolyP", "Phyt", "AEP")]

# Drop Missing Branches and data
nj.rooted <- drop.tip(nj.rooted, c("LL11A", "LL15", "WG37", "WG30A", "WG32", "LL12A"))
traits <- traits[!rownames(traits) == "LL12", ]

require(phylobase)
require(adephylo)
x <- phylo4d(nj.rooted, traits)
table.phylo4d(x,treetype="clad", show.node=FALSE, cex.leg=0.5, cex.label = 0.5,
use.edge.length=FALSE, edge.color="blue", edge.width=2, box=FALSE, las = 1) 




library(latticeExtra)
dd.col <- as.dendrogram(hc)
col.ord <- order.dendrogram(dd.col)
mat <- matrix(rnorm(4*4),nrow=4)
colnames(mat) <- tree$tip.label
rownames(mat) <- tree$tip.label
levelplot(mat[tree$tip,tree$tip],type=c('g','p'),
          aspect = "fill",
          colorkey = list(space = "left"),
          legend =
            list(right =
                   list(fun = dendrogramGrob,
                        args =
                          list(x = dd.col, 
                               side = "right",
                               size = 10))),
          panel=function(...){
            panel.fill('black',alpha=0.2)
            panel.levelplot.points(...,cex=12,pch=23)
          }
)




```


### B. Calculating Niche Breadth
We calcualte the niche breadth (*nb*) index from Levins (1968) which is defined as $\frac{1}{\left( n \cdot \Sigma p_{xi}^{2}}\right)$, where ni is each resource 

single isolate
```{r}
levins <- function(p_xi = ""){
  x = 0
  for (i in p_xi){
    x = x + i^2
    }
    nb = 1 / (length(p_xi) * x) 
  return(nb)
}
```  

```{r}
levins.2 <- function(p_xi = ""){
  p_xi = as.numeric(p_xi)
  nb = 1 / (length(p_xi) * (p_xi %*% p_xi))
  return(nb)
}  
levins.2(p.growth[1, ])

```
## 8) PHYLOGENETIC SIGNAL
**Phylogenetic signal is outlined in Paradis (2012) on pp 236-239
**Can we take a big-picture look at the phylogeny and traits combined and deteremine whether or not their is "signal" beyond null Brownian motion?
Hopefully, we pick an example where the answer is "yes"
** visualig co-mapping, mantel tests

## 9) PHYLOGENETIC INDEPENDENT CONTRASTS
**Phylogenetic independent contrasts are outlined in Paradis (2012) on pp 204-209
**Can we take a trait-peformance relationship that's siginficant and correct for phylogeny? 
Is the relationship still significant? 
Do the parameters or explained varition change?

