---
title: "Phylogenetic Diversity - Traits"
author: "Z620: Quantitative Biodiversity, Indiana University"
date: "February 20, 2015"
header-includes:
   - \usepackage{array}
output: pdf_document
geometry: margin=2.54cm
---

## OVERVIEW

## 1) SETUP
### A. Retrieve and Set Your Working Directory

```{r, results = 'hide'}
rm(list = ls())
getwd()
setwd("~/GitHub/QuantitativeBiodiversity/Assignments/PhyloTraits")
```

### B. Load Packages 

What are these packages and why are we using them?

```{r, results = 'hide', message = FALSE, warning = FALSE} 
require("muscle")
require("ape")
require("seqinr")
require("phangorn")
```

## 2) DESCRIPTION OF DATA
The meintenance of biodiversity is thought to be influenced by trade-offs among species. 
One such trade-off involves species that are highly specialized at using a single resource. 
However, this may come at the cost of not being able to use other resoruces as well.
We set out to test this hypothesized trade-off in bacteria by assessing generalist and specialist strategies on different forms of phopshorus, which commonly limits growth and reproduction of populations in freshwater ecosystems.
More..

## 3) SEQUENCE ALIGNMENT
It appears that DNA sequences can be alligned in R using at least two packages: `ape` and `muscle`. 
In `ape`, alignments can be done with the functions `clustal`, `muscle`, and `tcoffee`, all which seem to have a range of options. 
However, it seem that these functions call on other installed programs, like ClustalX. 
In contrast, the `muscle` package aligns sequences in a "stand alone" fashion. 

```{r}
seq.aln <- muscle::muscle(seqs="./data/p.isolates.fasta", out = "./data/p.isolates.afa") 
```

## 4) VISUALIZE THE ALIGNMENT
```{r}
read.aln <- read.alignment(file = "./data/p.isolates.afa", format = "fasta") # seqinr command to read muscle align
p.DNAbin <- as.DNAbin(read.aln) # ape command to convert fasta file into DNAbin filetype
x <- p.DNAbin[,100:500] # identify region (in bp of 16S rRNA) to visuzlize
image(x, cex.lab = 0.5) # ape command to visusalize seq align
grid(ncol(x),nrow(x),col="lightgrey") # ape command to add grid
```

## 5) EVOLUTIONARY RECONSTRUCTION
The `ape` package uses the `dist.dna` function to create distances for various DNA substitution models. 
```{r}
seq.dist <- dist.dna(p.DNAbin, model = "K80", pairwise.deletion = FALSE) # ape: Kimuraâ€™s 2-parameters distance
```

## 6) MAKE A NEIGHBOR-JOINING and UPGMA TREE
```{r}
nj.tree <- nj(seq.dist) # ape command for Neighbor Joining
upgma.tree <- upgma(seq.dist)
outgroup <- match("Methanosarcina", nj.tree$tip.label)
nj.rooted <- root(nj.tree, outgroup, resolve.root=TRUE)
upgma.rooted <- root(upgma.tree, outgroup, resolve.root=TRUE)
layout(matrix(c(1,2), 2, 1), height=c(2,2))
par(mar = c(1,1,1,1))
plot.phylo(nj.rooted, main = "NJ", "phylogram", use.edge.length = FALSE, direction = "right", cex = 0.5, label.offset = 1) # ape command
plot(upgma.rooted, main = "UPGMA", use.edge.length = FALSE, direction = "right", cex = 0.5, label.offset = 1)
```

## 7) MAKE A PARSIMONY TREE
Using package `phangorn`.
Requires phyDat formatted objects.
There are functions like `optim.parsimony` that peforms tree rearragements via nearest-neighbor exchange and `pratchet` which uses parsimony ratchet to find trees with lower parsimony score.
Type the following at the R terminal for a detailed exmaple: vignette('Trees')

```{r}
# read.aln.mat <- as.matrix(read.aln)
# read.aln.phydat <- phyDat(p, type = "DNA")
# seq.dist.phydat <- dist.dna(as.DNAbin(read.aln.phydat))
# tree.nj <- nj(seq.dist.phydat)
# parsimony(tree.nj, read.aln.phydat)
# tree.pars <- optim.parsimony(tree.nj, read.aln.phydat)
# tree.ratch <- pratchet(read.aln.phydat, trace = 0)
# parsimony(c(tree.pars,tree.ratch),read.aln.phydat)
# plot(tree.pars, main = "parsimony", use.edge.length = FALSE, direction = "right", cex = 0.5, label.offset = 1)
```

## 6) MAXIMUM LIKELIHOOD ESTIMATION AND BOOTSTRAP SUPPORT
** Beware really long, something is not right. 
** Discussed by Paradis (2012) on pp 138-159
```{r}
# read.aln.mat <- as.matrix(read.aln)
# read.aln.phydat <- phyDat(read.aln.mat, type = "DNA")
# ml <- pml(nj.rooted, data = read.aln.phydat, k =4, inv = 0.2) 
# 
# seq.dist.phydat
# 
# 
# ml <- pml(tree.nj, data = seq.dist.phydat) 
# 
# seq.dist.phydat
# 
# 
# data(yeast)
# tree <- NJ(dist.logDet(yeast))
# fit <- pml(tree, yeast, k=4, inv=0.2)

```

## 7) MAPPING TRAITS ONTO TREES

### A. Loading Trait Database
```{r}
p.growth <- read.table("./data/p.isolates.stdgrowth.txt", sep = "\t", header = TRUE, row.names = 1)
#p.growth <- as.data.frame(t(p.growth))
```


### Mapping Traits on Tree
```{r}
nj.tree <- bionj(seq.dist) # ape command for Neighbor Joining
outgroup <- match("Methanosarcina", nj.tree$tip.label)
nj.rooted <- root(nj.tree, outgroup, resolve.root=TRUE)
nj.rooted <- drop.tip(nj.rooted, "Methanosarcina")
traits <- p.growth[,c("ATP", "SRP", "PolyP", "Phyt", "AEP")]

# Drop Missing Branches and data
nj.rooted <- drop.tip(nj.rooted, c("LL11A", "LL15", "WG37", "WG30A", "WG32", "LL12A"))
traits <- traits[!rownames(traits) == "LL12", ]

require(phylobase)
require(adephylo)
x <- phylo4d(nj.rooted, traits)
table.phylo4d(x,treetype="clad", show.node=FALSE, cex.leg=0.5, cex.label = 0.5,
use.edge.length=FALSE, edge.color="blue", edge.width=2, box=FALSE, las = 1) 




library(latticeExtra)
dd.col <- as.dendrogram(hc)
col.ord <- order.dendrogram(dd.col)
mat <- matrix(rnorm(4*4),nrow=4)
colnames(mat) <- tree$tip.label
rownames(mat) <- tree$tip.label
levelplot(mat[tree$tip,tree$tip],type=c('g','p'),
          aspect = "fill",
          colorkey = list(space = "left"),
          legend =
            list(right =
                   list(fun = dendrogramGrob,
                        args =
                          list(x = dd.col, 
                               side = "right",
                               size = 10))),
          panel=function(...){
            panel.fill('black',alpha=0.2)
            panel.levelplot.points(...,cex=12,pch=23)
          }
)




```


### B. Calculating Niche Breadth
We calcualte the niche breadth (*nb*) index from Levins (1968) which is defined as $\frac{1}{\left( n \cdot \Sigma p_{xi}^{2}}\right)$, where ni is each resource 

single isolate
```{r}
levins <- function(p_xi = ""){
  x = 0
  for (i in p_xi){
    x = x + i^2
    }
    nb = 1 / (length(p_xi) * x) 
  return(nb)
}
```  

```{r}
levins.2 <- function(p_xi = ""){
  p_xi = as.numeric(p_xi)
  nb = 1 / (length(p_xi) * (p_xi %*% p_xi))
  return(nb)
}  
levins.2(p.growth[1, ])

```
## 8) PHYLOGENETIC SIGNAL
**Phylogenetic signal is outlined in Paradis (2012) on pp 236-239
**Can we take a big-picture look at the phylogeny and traits combined and deteremine whether or not their is "signal" beyond null Brownian motion?
Hopefully, we pick an example where the answer is "yes"
** visualig co-mapping, mantel tests

## 9) PHYLOGENETIC INDEPENDENT CONTRASTS
**Phylogenetic independent contrasts are outlined in Paradis (2012) on pp 204-209
**Can we take a trait-peformance relationship that's siginficant and correct for phylogeny? 
Is the relationship still significant? 
Do the parameters or explained varition change?

