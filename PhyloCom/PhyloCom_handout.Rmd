---
title: "Phylogenetic Diversity - Communities"
author: "Z620: Quantitative Biodiversity, Indiana University"
date: "February 26, 2015"
header-includes:
   - \usepackage{array}
output: pdf_document
geometry: margin=2.54cm
---

## OVERVIEW
Taxonomic measures of $\alpha$- and $\beta$-diversity do not integrate evolutionary information into estimates of community diversity 
In this handout, we will introduce methods used in phylogenetic community ecology.
These methods will allow us to account for phylogenetic diversity and provide insight into the mechansisms that give rise to over- and under-dispersion (i.e., clustering) of biological communities. 

After completing this exercise you will know how to:

1.  measure phylogenetic $\alpha$ diversity
2.  measure phylogenetic $\beta$ diversity
3.  construct phylogenetic diversity-area relationships

## 1) SETUP
### A. Retrieve and Set Your Working Directory

```{r, results = 'hide'}
rm(list = ls())
getwd()
setwd("~/GitHub/QuantitativeBiodiversity/Assignments/PhyloCom")
```

### B. Load Packages 
We will be relying heavily on the R package `picante`. 
This package has many of the functions that are contained in the software Phylocom, which is used for the analysis of phylogenetic community structure and character evolution (http://phylodiversity.net/phylocom/).

After the initial installation of these packages using the `install.packages()` fucntion, let's load the packages and their dependencies with the `require()` function:

```{r, results = 'hide', message = FALSE, warning = FALSE} 
require("picante")
require("ape")
require("seqinr")
```

### C. Load Source Code
In addition to relying on the installation of contributed packages, this week we will also be using a source code file.
A source code file is a file containing user-defined functions that are required for an analysis.
The benefit of source files is that they can easily be used in multiple projects without fear of having code variation.
Here we will be using a source code file that includes a function for reading in the output files from the popular community sequencing software `mothur` (http://www.mothur.org/).

```{r}
source("./bin/MothurTools.R")
```

## 2) DESCRIPTION OF DATA
We will revisit the environmental, geographic, and biological data that we used a couple of weeks ago that was collected from the Brown County refuge ponds.
Perhaps a bit more info on the nature of the sequence data and how we generated the phylogeny. 
Also, maybe reference to the reference data base. 

## 3) LOADING OF DATA

First, we'll load the environmental data, along with the site-by-species matrix:
```{r}
require("reshape")

# Load Environmental Data
env <- read.table("data/20130801_PondDataMod.csv", sep = ",", header = TRUE)

# Load Site-by-Species Matrix
comm <- read.otu(shared = "./data/INPonds.final.rdp.shared", cutoff = "1")

# Select Only DNA 
comm <- comm[grep("*-DNA", rownames(comm)), ] # insert comment, i.e., what's this do?
rownames(comm) <- gsub("\\-DNA", "", rownames(comm)) # insert comment
rownames(comm) <- gsub("\\_", "", rownames(comm)) # insert comment

# Remove Zero-Occurrence Species
comm <- comm[ , colSums(comm) > 0]

# Taxonomy Data
tax <- read.tax(taxonomy = "./data/INPonds.final.rdp.1.cons.taxonomy")
```

Now, let's load and process some of the phylogenetic data:
```{r}
# Import the Alignment File {seqinr}
ponds.cons <- read.alignment(file = "./data/INPonds.final.rdp.1.rep.fasta", format = "fasta")  

# Rename OTUs in FASTA file
ponds.cons$nam <- gsub("\\|.*$", "", gsub("^.*?\t", "", ponds.cons$nam))

# Import Outgroup FASTA File
outgroup <- read.alignment(file = "./data/methanosarcina.fasta", format = "fasta")

# Convert Alignment File to DNAbin Object {ape}
DNAbin <- rbind(as.DNAbin(outgroup), as.DNAbin(ponds.cons))

# Visusalize Sequence Alignment {ape}
#image.DNAbin(DNAbin, show.labels=T, cex.lab = 0.05, las=1) 

# Create Distance Matrix with the Jukes Cantor "JC" Model {ape}
seq.dist.jc <- dist.dna(DNAbin, model = "JC", pairwise.deletion = FALSE)

# Use Neighbor Joining Algorithm to Construct Tree, a 'phylo' Object {ape}
phy.all <- bionj(seq.dist.jc)

# Drop Tips of Zero-Occurrence OTUs
phy <- drop.tip(phy.all, phy.all$tip.label[!phy.all$tip.label %in% c(colnames(comm), "Methanosarcina")])

# Root Tree
# Identify Outgroup Sequence
outgroup <- match("Methanosarcina", phy$tip.label)

# Root the Tree {ape}
phy.rooted <- root(phy, outgroup, resolve.root = TRUE)

# Plot the Rooted Tree{ape}
par(mar = c(1,1,2,1) + 0.1)
plot.phylo(phy.rooted, main = "Neigbor Joining Tree", "phylogram", use.edge.length = FALSE,
           direction = "right", cex = 0.6, label.offset = 1)
add.scale.bar(cex = 0.7)

phy <- phy.rooted

# MEM: "Need to figure out how to add an outgroup for rooting; otherwise this looks pretty good.
# I'm thinking that we can just append the sequence to this file. 
# I'll probably align an outgroup to silva first to make things easier though."
```

## Example from Picante Vignette: way to move forward while figuring out the pond data set
```{r}
# From Picante Vignette (http://goo.gl/EYOZ55)
data(phylocom)
names(phylocom)

# We need to make sure that the names associate with the tree match up with the names in the site-by-species matrix in `comm` below. 
phy.eg <- phylocom$phy

# Community Data: Site-by-Species Matrix
comm.eg <- phylocom$sample
```

## 4) PHYLOGENETIC ALPHA DIVERSITY

### A.  Faith's Phylogenetic Diversity (PD)
In 1992, Daniel Faith developed a diversity metric called Faith's PD (http://goo.gl/wM08Oy).
The metric sums the branch lengths for each species in a sample from the root to the tip of the tree.
The value of the metric captures ... and can be interpreted as ... and used to ...  --Ken

Faith's PD can be implemented in R using the `pd()` function in the `picante` package. 
A phylognetic tree containing the regional species pool is required. 
In addition to returning Faith's PD, the `pd()` function also returns species richness (SR).
SR is the same as observed richness ($\S_{obs}), which was introduced in the $\alpha$ diversity module. 

```{r}
# Compares PD and Taxonomic Richness {picante}
pd <- pd(comm, phy, include.root=FALSE)
```

Let's compare the phylogenetic diversity (PD) estimates with taxonomic richness (SR) of our samples.
We'll use a log-log transformation, so that the slope of the relationship gives us a power-law exponent which describes how PD scales with SR.

```{r}
# Biplot of SR and PD, log-transforming
par(mar = c(5, 5, 2, 1) + 0.1)

plot(log(pd$SR), log(pd$PD), 
     pch = 20, col = "red", las = 1,
     xlab = "log(SR)", ylab = "log(PD)", 
     main="Phylodiversity (PD) vs. \nTaxonomic richness (SR)")

OLS <- lm('log(pd$PD) ~ log(pd$SR)')
abline(OLS, col="red", lw=2)
exponent <- round(coefficients(OLS)[2], 3)
legend("topleft", legend=paste("Scaling exponent=", exponent), bty="n", lw=2, col = "red") 
```

***Question 1***: Compare patterns of PD and SR. 
a.  Is taxonomic richness correlated with phylodiversity?
b.  Mathematically, why should they be correlated?  
c.  Under what conditions would you expect these two estimates of diversity to deviate from one another?

> ***Answer 1a***:  
> ***Answer 1b***:  
> ***Answer 1c***:  

### B. Randomizations and Null Models
Randomizations are a way of resampling our data to assess whether or not observed patterns are different from a null expectation. 
A number of the functions in `picante` allow us to specify different null models as an argument. 
These null models can control for features such as species richness, species occurrence frequencey, and the diversity of the regional species pool. 
The following table describes some of the null models that are available to us when using `picante`:

\begin{center}
\hyphenpenalty 10000
\exhyphenpenalty 10000
\begin{tabular}{ m{5cm}  m{10cm} }
  \textbf{Null Model} & \textbf{Description} \\
  \hline \hline \\ [-1.5ex]
  \textbf{taxa.labels} & 
  Shuffles taxa labels across tips of phylogeny (across all taxa included in phylogeny) \\
  \\ [-1.5ex]
  \textbf{richness} & 
  Randomizes community data matrix abundances within samples (maintains sample species richness) \\
  \\ [-1.5ex]  
  \textbf{frequency} & 
  Randomizes community data matrix abundances within species (maintains species occurence frequency) \\
  \\ [-1.5ex]   
  \textbf{sample.pool} & 
  Randomizes community data matrix by drawing species from pool of species occurring in at least one community (sample pool) with equal probability \\
  \\ [-1.5ex]  
    \textbf{phylogeny.pool} & 
  Randomize community data matrix by drawing species from pool of species occurring in at least one community (sample pool) with equal probability \\
  \\ [-1.5ex]
  \textbf{independentswap} & 
  Randomizes community data matrix with the independent swap algorithm (Gotelli 2000) maintaining species occurrence frequency and sample species richness \\
  \\ [-1.5ex]
  \textbf{trialswap} & 
  Randomizes community data matrix with the trial-swap algorithm (Miklos \& Podani 2004) maintaining species occurrence frequency and sample species richness \\
  \\ [-1.5ex]
    \hline
\end{tabular}
\end{center}

Now, we are going to use the `ses.pd()` function in `picante`. 
This function estimates the standardized effect size ("ses") by comparing the observed PD value to the PD values generated from a tree randomized under a null model. 

```{r}
# Need to root tree first
# Estimate Standardized Effect Size of PD via Randomization {picante} 
ses.pd <- ses.pd(comm, phy, null.model = "taxa.labels", runs = 100, iterations = 2, include.root=FALSE)
```

***Question 2***: Using the `help()` function, choose two null models that can be used with `ses.pd()`.
Rerun `ses.pd()` with these null models.
Compare and interpret the output. 

> ***Answer 2***:  

### B.  Net Relatedness Index (NRI)
One common way to test for phylogenetic clustering and overdispersion is to use the Net Relatedness Index (NRI).
NRI is caculated with the following equation: $\ - \frac{MPD_{obs} - \overline{MPD_{null}}}{\sigma \left (MPD_{null} \right )}$ where $MPD_{obs}$ is the mean phylogenetic distance cacluated from pairwise branch lengths in a sample, $\overline{MPD_{null}}$ is the mean of the MPD values generated from a tree randomized under a null model, and $\sigma MPD_{null}$ is the standard deviation of the MPD values generated from a tree randomized under a null model. 
Negative NRI values indicate that a sample is phylogenetically overdispersed; that is, taxa are less related to one another than expected. 
Positive NRI values indicate that a sample is phylogentically underdispersed, or clustered, such that taxa are more closely related to on another than expected. 
Let's use `picante` to calucate NRI:

```{r}
# Create a Phylogenetic Distance Matrix {picante}
# Important Concept? Variance-Covariance? Not exactly the same thing...
phydist <- cophenetic(phy)

# Estimate Standardized Effect Size of NRI via Randomization {picante} 
ses.mpd <- ses.mpd(comm, phydist, null.model = "taxa.labels", abundance.weighted = FALSE, runs = 1000)

# Calculate NRI
NRI <- as.matrix(-1 * ((ses.mpd[,1] - ses.mpd[,2]) / ses.mpd[,3]))
rownames(NRI) <- row.names(ses.mpd)
colnames(NRI) <- "NRI"
```

### C.  Nearest Taxon Index (NTI)
Another way to test for phylogenetic clustering and oversdispersion in a sample is to use the Nearest Taxon Index (NRI).
This index is similar to NRI, but uses the mean nearest phylogenetic neighbor distance (MNND) insted of MPD. 
Just like NRI, we peform randomizations and use this information to estimate that standardized effect size. 
Last, we multiply by -1 so that negative values correspond with overdispersion and positive values correspond with clustering. 

```{r}
# Estimate Standardized Effect Size of NRI via Randomization {picante} 
ses.mntd <- ses.mntd(comm, phydist, null.model = "taxa.labels", abundance.weighted = FALSE, runs = 1000)

# Calculate NTI
NTI <- as.matrix(-1 * ((ses.mntd[,1] - ses.mntd[,2]) / ses.mntd[,3]))
rownames(NTI) <- row.names(ses.mntd)
colnames(NTI) <- "NTI"
```

***Question 3***: In the NRI and NTI examples above, the arguments "abundance.weighted = FALSE" means that the indices were calculated on presence-absence data.
Modify and rerun the code so that NRI and NTI are caculated using abundance data. 
How does this affect the interpretation of NRI and NTI?

> ***Answer 3***:  


## POTENTIAL EXERCISE: HAVE STUDENTS LOOK FOR CORRELATIONS BETWEEN NRI/NTI AND ENVIRONMENTAL VARIABLES. 
## DOES CLUSTERING/DISPERSION CHANGE ALONG GRADIENTS OR WITH PD? IF SO, WHAT ARE SOME DIFFERENT EXPLANATIONS?


## 5) PHYLOGENETIC BETA DIVERSITY 

```{r}
comdist.result <- comdist(comm, phydist)
comdist.result
comdist.clusters <- hclust(comdist.result)
plot(comdist.clusters)

#  phyloordination ?Phylogenetic beta diversity measures can be used with any method based onvmeasuring among-community distances. For example, they could be used in a cluster analysis or phyloordination to group communities based on their evolutionaryvsimilarity, or they could be compared with spatial or environmental distances separating communities using a Mantel test. The code below calculates MPD between pairs of communities, and uses these phylogenetic distances to cluster communities based on their phylogenetic similarity:
```

Ordinations: PCoA taxo  vs. UNIFRAC
http://www.inside-r.org/packages/cran/picante/docs/unifrac
http://cran.r-project.org/web/packages/GUniFrac/GUniFrac.pdf
http://joey711.github.io/phyloseq-demo/unifrac.html  <- out of date. not worth it

```{r}

unifrac(comm, phydist)
# GUniFrac(comm, phydist)   # Tree Must be rooted


GUniFrac(otu.tab, tree, alpha = c(0, 0.5, 1))

# Calculate the UniFracs
unifracs <- GUniFrac(otu.tab.rff, throat.tree, alpha=c(0, 0.5, 1))$unifracs

#  Combine unweighted and weighted UniFrac for testing
PermanovaG(unifracs[, , c("d_1", "d_UW")] ~ groups)
# Combine d(0), d(0.5), d(1) for testing
PermanovaG(unifracs[, , c("d_0", "d_0.5", "d_1")] ~ groups)



phylosor.rnd(samp,tree, cstSor=TRUE, null.model=c("taxa.labels",
    "frequency","richness","independentswap","trialswap"),
    runs=999, iterations=1000)

```


## 6) PHYLOGENETIC DIVERSITY-AREA RELATIONSHIP
Description 

Calculate nonspatial and spatial phylogenetic diversity area curves for an ecological data set.
According to Helmus and Ives, the code assumes that the site by species matrix is ordered such that consecutive samples in the matrix are spatially closer to each other than to non-consecutive samples.
There are serious serious issues with that assumption, but here's goes...


```{r}
pdac.psv <- function(comm, phy.rooted, reps=100, lt=1){
  
  Y <- comm # Site by species matrix
  Y[Y > 0] <- 1 # Assign a 1 to every element of Y greater than 1; turns Y into presence absence
  
  m <- dim(Y)[1] # number of sites
  SAcurve <- NULL
  
  for(i in 1:2){
    
    for(a in 1:round(lt * m)){
      ratio <- NULL
      
      for(tt in 1:reps){
        if(i == 1){  # nonspatial curve
          pick <- sample(m)
          pick <- pick[1:a]
          } 
        
        else {      # spatial curve
          pick <- sample(m+1-a)[1]
          pick <- pick:(pick+a-1)
          }
        
        if(a==1) { 
          y <- Y[pick,]
          } 
        
        else {
          y <- colSums(Y[pick,]) > 0
          }
          
        ratio <- rbind(ratio,psv(y, phy, compute.var=FALSE))
        }
      
      SAcurve <- rbind(SAcurve, c(i, a, mean(ratio[, 1], na.rm=TRUE),
                          sd(ratio[, 1], na.rm=TRUE), mean(ratio[, 2]), sd(ratio[, 2])))
    }
  }
  
  SAcurve<-data.frame(SAcurve)
  SAcurve[SAcurve[,1] == 1, 1] <- "nonspatial"
  SAcurve[SAcurve[,1] == "2", 1] <- "spatial"
  
  colnames(SAcurve) <- c("curve","aggregate","mean.psv","sd.psv","mean.sr","sd.sr")
  return(SAcurve)
  
}
```


An example
```{r}
pdac <- pdac.psv(comm[1:10, 100:200], phy)

par(las=1)
plot(pdac[, 2:3], type = "n", ylab = "phylogenetic diversity (PSV)", xlab = "area (# of samples)")

lines(pdac[pdac[, 1] == "nonspatial", 2:3], col="red")
points(pdac[pdac[, 1] == "nonspatial", 2:3], col="red", pch=19)

lines(pdac[pdac[, 1] == "spatial",2:3],col="blue")
points(pdac[pdac[, 1] == "spatial",2:3],col="blue",pch=19)

legend(x=4,y=0.78,pch=19,legend=c("nonspatial","spatial"),lty=1,col = c("red","blue")) 
```







## 7) HOMEWORK 

1.  
2.  Use Knitr to create a pdf of your completed PhyloTraits_handout.Rmd document, push it to GitHub, and create a pull request.
The due date for this assignment is February 25, 2015 at 12:00 PM (noon).
